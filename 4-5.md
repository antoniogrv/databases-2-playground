####################
### INTRODUZIONE ###
####################

Le basi di dati sono fisicamente memorizzate come file di record, che a loro volta sono tipicamente memorizzati su dischi magnetici. I dati memorizzati su disco sono organizzati come file di record. Ogni record è costituito da una collezione di valori di dati che possono essere interpretati come fatti relativi alle entità, ai loro attributi e alle loro associazioni. I record dovrebbero essere memorizzati su disco in modo da rendere possibile individuarne efficientemente la collocazione ogni volta che se ne ha bisogno. Ci sono molte organizzazioni primarie dei file che determinano come sono collocati fisicamente sul disco i record di un file, e perciò come si può accedere ad essi. Un file heap (file non ordinato) colloca i record su disco senza un ordine particolare, semplicemente aggiungendo nuovi record alla fine del file, mentre un file sequenziale (file ordinato) tiene i record in ordine sulla base del valore di un campo particolare (detto chiave di ordinamento). Un file hash usa una funzione hash applicata a un campo particolare (detto chiave hash) per determinare la collocazione di un record su disco. Altre organizzazioni primarie dei file, come i B-Tree, usano per l’appunto strutture ad albero. Un’organizzazione secondaria, o struttura di accesso ausiliaria, consente un accesso efficiente ai record di un file basata su campi alternativi rispetto a quelli che sono stati usati per l’organizzazione primaria dei file.

########################
### DISCHI MAGNETICI ###
########################

I dischi magnetici sono usati per memorizzare grandi quantità di dati. La più elementare unità dati su disco è il singolo bit di informazione. Magnetizzando un’area su disco in certi modi, si può far sì che essa rappresenti un valore di bit 0 o 1. Per codificare le informazioni, i bit sono raggruppati in byte. L’informazione è memorizzata sulla faccia di un disco su circonferenze concentriche di piccola larghezza, ciascuna delle quali ha un diverso diametro. Ogni circonferenza è detta traccia (track). Per le pile di dischi le tracce con lo stesso diametro sulle varie facce sono dette cilindro per la struttura che formerebbero se connesse nello spazio. Il concetto di cilindro è importante perché i dati memorizzati in un cilindro possono essere recuperati molto più velocemente se fossero distribuiti tra cilindri diversi. La suddivisione di una traccia in settori è codificata nell’hardware sulla faccia del disco e non può essere cambiata. La divisione di una traccia in blocchi di disco (o pagine) di uguale dimensione è fissata dal sistema operativo durante la formattazione (o inizializzazione) del disco. La dimensione di un blocco è fissata durante l’inizializzazione e non può essere cambiata dinamicamente.  I blocchi sono separati da spazi tra blocchi di dimensioni fisse, che comprendono informazioni di controllo codificate appositamente, scritte durante l’inizializzazione del disco. Queste informazioni sono usate per determinare quale blocco della traccia segue ciascuno spazio tra blocchi. Un disco è un dispositivo indirizzabile ad accesso casuale. Il trasferimento dati tra la memoria centrale e il disco avviene in unità di blocchi di disco. L’indirizzo hardware di un blocco – una combinazione di numero di faccia, numero di traccia (nella faccia) e numero di blocco (nella traccia) – è fornito all’hardware dell’input/output (I/O) del disco. Viene anche fornito l’indirizzo di un buffer – un’area riservata di locazioni contigue in memoria centrale che può contenere un blocco. Con un comando read il blocco dal disco è copiato nel buffer, mentre con un comando write il contenuto del buffer è copiato nel blocco di disco. Talora possono essere trasferiti come una cosa sola molti blocchi contigui, detti cluster. In questo caso la dimensione del buffer è adattata per corrispondere al numero di byte presenti nel cluster. L’effettivo meccanismo hardware che legge o scrive un blocco è la testina di lettura/scrittura. Tempo di posizionamento + latenza + trasferimento del blocco tramite attuatore è il tempo totale.

##############
### RECORD ###
##############

I dati sono normalmente memorizzati sotto forma di record. Ogni record consiste di una collezione di valori collegati, dove ogni valore è formato da uno o più byte e corrisponde a un particolare campo del record. I record di solito descrivono le entità e i loro attributi. Per esempio, un record IMPIEGATO rappresenta un’entità impiegato, e il valore di ciascun campo del record specifica alcuni attributi di quell’impiegato, come NOME, DATA_NASCITA, STIPENDIO o SUPERVISORE. Una collezione di nomi di campi e dei tipi di dati corrispondenti costituisce una definizione di tipo di record o formato di record. Un tipo di dati, associato a ciascun campo, specifica il tipo di valori che possono essere assunti da quel campo. Il tipo di dati di un campo è di solito uno dei tipi di dati standard usati in programmazione. 

Un file è una sequenza di record. In molti casi tutti i record presenti in un file fanno parte dello stesso tipo di record. Se ogni record nel file ha esattamente la stessa dimensione (in byte), si dice che il file è costituito da record a lunghezza fissa. Se record diversi nel file hanno dimensioni diverse, si dice che il file è costituito da record a lunghezza variabile. I record di un file devono essere ripartiti su blocchi di disco perché un blocco è l’unità di trasferimento dati tra disco e memoria.

Per la ricerca di un record su disco, uno o più blocchi sono copiati nel buffer di memoria centrale. Quindi i programmi ricercano il record o i record desiderati dentro i buffer, usando le informazioni presenti nell’header del file. Se l’indirizzo del blocco che contiene il record desiderato non è noto, i programmi di ricerca devono effettuare una ricerca lineare attraverso i blocchi del file. Ogni blocco del file è copiato in un buffer ed esaminato fino a che il record è localizzato o tuti i blocchi del file sono stati esaminati senza successo.

###################
### ALLOCAZIONE ###
###################

Ci sono molte tecniche standard per allocare i blocchi di un file su disco. Nell’allocazione continua i blocchi del file sono allocati su blocchi di disco consecutivi: ciò rende molto veloce la lettura dell’intero file con l’uso della doppia bufferizzazione, ma allo stesso tempo rende difficile l’aumento delle dimensioni del file. 
Nell’allocazione collegata ogni blocco contiene un puntatore al successivo blocco del file: ciò facilita l’aumento delle dimensioni del file ma rallenta la lettura dell’intero file. Una combinazione delle due alloca cluster di blocchi di disco consecutivi, con i cluster collegati tra loro. I cluster sono talora detti segmenti del file o estensioni del file. Un’altra possibilità è quella di usare un’allocazione indicizzata, dove uno o più blocchi di indici contengono puntatori agli effettivi blocchi dei file. È anche comune usare combinazioni di queste tecniche.

##########################################
### FILE DI RECORD NON ORDINATI (HEAP) ###
##########################################

In questo tipo di organizzazione, la più semplice e la più fondamentale, i record sono collocati nel file nell’ordine in cui sono inseriti, cosicché i nuovi record sono inseriti alla fine del file. Un’organizzazione di questo tipo è detta file heap. L’inserimento di un nuovo record è molto efficiente: l’ultimo blocco di disco del file viene copiato in un buffer, viene aggiunto il nuovo record e poi il blocco viene riscritto sul disco. L’indirizzo dell’ultimo blocco del file viene tenuto nell’header del file. Però la ricerca di un record attraverso una qualsiasi condizione di ricerca comporta una ricerca lineare sul file blocco per blocco – una procedura dispendiosa. Per cancellare un record, un programma deve dapprima trovare il suo blocco, copiare il blocco in un buffer, quindi cancellare il record dal buffer e infine riscrivere il blocco su disco.

########################################
### FILE DI RECORD ORDINATI (SORTED) ###
########################################

È possibile ordinare fisicamente i record di un file su disco basandosi sui valori di uno dei loro campi, detto campo di ordinamento. Ciò porta a un file ordinato. Se il campo di riordinamento è anche un campo chiave del file – un campo per cui è garantita l’esistenza di un valore univoco in ogni record – allora esso è detto chiave di ordinamento del file. I file di record ordinati presentano alcuni vantaggi sui file di record non ordinati. In primo luogo, la lettura dei record secondo l’ordine dei valori della chiave di ordinamento diventa estremamente efficiente, perché non è richiesta alcuna azione di riordinamento. In secondo luogo, trovare il record successivo a quello corrente, secondo l’ordine della chiave di ordinamento, di solito non richiede accessi aggiuntivi ai blocchi, perché il record successivo è nello stesso blocco di quello corrente. Raramente usati nei DB.

#################
### FILE HASH ###
#################

Un altro tipo di organizzazione primaria di file è basato sull’hash, che fornisce un accesso molto rapido ai record sotto certe condizioni di ricerca. Questa organizzazione è detta di solito file hash. La condizione di ricerca deve essere una condizione di uguaglianza su un campo singolo, detto campo hash del file. Di solito il campo hash è anche un campo chiave del file; in questo caso è detto chiave hash. L’idea che sta dietro l’hash è quella di fornire una funziona h, detta funzione hash o funzione di randomizzazione, che è applicata al valore del campo hash di un record e fornisce l’indirizzo del blocco di disco in cui è memorizzato il record. Una ricerca del record all’interno del blocco può essere effettuata in un buffer in memoria centrale. Per la maggior parte dei record si ha bisogno solo di un accesso a un singolo blocco per recuperare quel record. L’hash è usato anche come una struttura di ricerca interna in un programma, ogni volta che a un gruppo di record si accede esclusivamente usando il valore di un campo. Per file interni, l’hash è tipicamente implementato con una tabella hash costruita usando un vettore di record. Si supponga che il campo di valori possibili per l’indice del vettore vada da 0 a M – 1; si ha pertanto M slot i cui indirizzi corrispondono agli indici del vettore. Si sceglierà allora una funzione hash che trasforma il valore del campo hash in un intero compreso tra 0 e M – 1.

L’hash per file su disco è detto hash esterno. Per adattarsi alle caratteristiche della memorizzazione su disco, lo spazio indirizzi obiettivo è fatto di bucket, ciascuno dei quali contiene più record. Un bucket è un blocco di disco o un cluster di blocchi contigui. La funzione hash mappa una chiave in un numero relativo per il bucket, piuttosto di assegnare al bucket un indirizzo di blocco assoluto. Una tabella contenuta nell’header del file converte il numero del bucket nel corrispondente indirizzo di blocco di disco. Con i bucket il problema delle collisioni è meno grave perché possono essere inviati nello stesso bucket senza causare problemi tanti record quanti ce ne stanno. 

L’hash fornisce il più rapido accesso possibile per il recupero di un record arbitrario dato il valore del suo campo hash. Anche se la maggior parte delle buone funzioni hash non mantengono i record nell’ordine fissato dai valori del campo chiave, ci sono alcune funzioni – dette order preserving (preservano l’ordine) – che lo fanno.

Un grave inconveniente dello schema hash statico esaminato finora è che lo spazio indirizza hash è fisso, e quindi è difficile espandere o ridurre il file dinamicamente. Gli schemi descritti di seguito tentano di porre rimedio a questa situazione. Il primo schema – hash estendibile – memorizza una struttura d’accessi insieme al file, e perciò per certi versi simile all’indicizzazione. La differenza principale è che la struttura d’accesso è basata sui valori che risultano dopo l’applicazione della funzione hash al campo di ricerca. Nell’indicizzazione, invece, la struttura d’accesso è basata sui valori del campo di ricerca stesso. La seconda tecnica, detta hash lineare, non richiede strutture d’accesso addizionali.Questi schemi hash traggono profitto dal fatto che il risultato dell’applicazione di una funzione hash è un intero non negativo, e perciò può essere rappresentato come un numero binario. La struttura d’accesso è costruita sulla rappresentazione binaria del risultato della funzione hash, che è una stringa di bit. Tale rappresentazione sarà detta valore hash di un record. I record sono distribuiti fra i bucket sulla base dei valori dei bit iniziali (leading bits) presenti nei loro valori hash.

Hash estendibile. Nell’hash estendibile si mantiene una specie di directory – un vettore di 2dindirizzi di bucket, dove d è detta profondità globale (global depth) della directory. Il valore intero corrispondente ai primi d bit (i più significativi) di un valore hash è usato come un indice per il vettore per determinare un elemento della directory, e l’indirizzo in corrispondenza a quell’elemento determina il bucket in cui sono memorizzati i record corrispondenti. 

Hash lineare. L’idea alla base dell’hash lineare è quella di consentire a un file hash di espandere e ridurre dinamicamente il suo numero di bucket senza aver bisogno di una directory.

# RAID

Un miglioramento importante nella tecnologia della memoria secondaria è rappresentato dallo sviluppo della tecnologia RAID, acronimo di Redundant Array of Inexpensive (o Indipendent) Disks. Lo scopo principale della tecnologia RAID è quello di uguagliare i tassi molto diversi di miglioramento delle prestazioni dei dischi rispetto a quelli della memoria principale e dei microprocessori. Mentre le capacitàdella RAM sono quadruplicate ogni due o tre anni, i tempi di accesso al disco stanno migliorando meno del 10% all’anno, e i tassi di trasferimento stanno aumentando approssimativamente del 2% annuo. In verità le capacità dei dischi stanno aumentando più del 50% all’anno, ma i miglioramenti nella velocità e nel tempo di accesso sono di entità molto inferiore. La soluzione naturale consiste in un grande vettore di piccoli dischi indipendenti che si comporta come un singolo disco logico di maggiori prestazioni. Viene usato un concetto detto data striping (suddivisione dei dati), che utilizza il parallelismo per incrementare le prestazioni del disco. Il data striping distribuisce i dati in modo trasparente fra più dischi, così che essi si comportino come un unico disco, grande e veloce. La suddivisione dei dati realizza anche un bilanciamento del carico fra i dischi. Per un vettore di n dischi la frequenza di un guasto è n volte quella che si ha per un solo disco. Mantenere una sola copia di dati in un tale vettore di 
dischi causerà una significativa perdita di affidabilità. Un’ovvia soluzione è quella di servirsi di una certa ridondanza dei dati in modo tale che i guasti ai dischi possano essere tollerati. Una tecnica per introdurre ridondanza è detta mirroring o shadowing. I dati sono scritti con ridondanza in due dischi fisici identici, che sono trattati come un solo disco logico. Quando i dati vengono letti, essi possono essere recuperati dal disco con minori ritardi di accodamento, di posizionamento e di rotazione.

I vettori di dischi si servono della tecnica del data striping per ottenere tassi di trasferimento migliori. La suddivisione su disco può essere eseguita a un livello di granularità più fine, scomponendo un byte di dati in bit e distribuendo i bit su dischi diversi. Perciò il data striping a livello di bit (bit-level data striping) consiste nello spezzare un byte di dati e nello scrivere il bit j nel j-esimo disco Ogni disco partecipa alla richiesta I/O. La granularità dell’interleaving dei dati può essere maggiore di un singolo bit; ad esempio, i blocchi di un file possono essere suddivisi su dischi diversi, dando origine allo striping a livello di blocco (block-level striping).

Sono state definite diverse organizzazioni RAID, basate su differenti combinazioni dei due fattori granularità dell’interleaving dei dati (striping) e modello usato per calcolare informazioni ridondanti. Nella proposta iniziale sono stati suggeriti i livelli di RAID da 1 a 5, mentre due livelli aggiuntivi – 0 e 6 – sono stati aggiunti in seguito. Il livello RAID 0 non presenta dati ridondanti, e perciò ha le migliori prestazioni in scrittura, dal momento che gli aggiornamenti non devono essere duplicati. Però le sue prestazioni in lettura non sono così buone come per il livello RAID 1, che usa dischi riflessi. In quest’ultimo è possibile un incremento di prestazioni, pianificando una richiesta di lettura al disco che presenta il minore ritardo previsto di posizionamento e di rotazione. Il livello RAID 2 usa una ridondanza analoga a quella usata in memoria di lavoro tramite l’uso di codici Hamming, che contengono bit di parità per diversi sottoinsieme sovrapposti di componenti. Il livello RAID 3 usa un solo disco di parità, facendo affidamento sul disk controller per riuscire a capire quale disco si è guastato. I livelli 4 e 5 usano il data striping a livello di blocco, con il livello 5 che distribuisce dati e informazioni di parità su tutti i dischi. Infine, il livello RAID 6 utilizza il cosiddetto schema di ridondanza P + Q che usa i codici di Reed e Solomon per proteggere fino a due guasti di disco usando solo due dischi ridondanti.

# Indici

In questa parte si darà per scontato che esista già un file con una certa organizzazione primaria con dati non ordinati, ordinati od organizzati secondo una funzione hash come quelle che sono state descritte in precedenza. Si descriveranno altre strutture ausiliarie di accesso chiamate indici, usate per velocizzare la ricerca dei record in risposta a determinate condizioni di ricerca. Gli indici tipicamente forniscono percorsi di accesso secondari, che offrono metodi alterativi per accedere ai record senza influenzare la posizione fisica dei record sul disco. Permettono un accesso efficace sulla base di campi d’indicizzazione che vengono utilizzati per costruire l’indice. Qualsiasi campo del file può essere usato per creare un indice e sullo stesso file possono essere costruiti più indici su campi differenti. È possibile immaginare una varietà di indici, ciascuno dei quali utilizza una particolare struttura dati per velocizzare la ricerca. Per trovare uno o più record nel fine in base a un determinato criterio di selezione su un campo di indicizzazione, inizialmente si deve accedere all’indice per conoscere la posizione di uno o più blocchi nel file in cui si trovano i record richiesti. I tipi di indici principali si basano su file ordinati (indici a un solo livello) a su strutture di dati ad albero (indici a più livelli, alberi B+). Gli indici possono essere creati anche tramite funzioni hash oppure altre strutture dati. Successivamente verranno descritti i diversi tipi di indici ordinati a un solo livello: primario, secondario e di cluster. Partendo da un indice a un solo livello memorizzato in un file ordinato, è possibile sviluppare ulteriori indici, dando origine al concetto di indici a più livelli.


## Indici ordinati ad un solo livello

L’idea su cui si basa la struttura di accesso degli indici ordinati è simile a quella che sta alla base dell’indice analitico di un libro di testo, il quale riporta in ordine alfabetico concetti fondamentali con indicazione del numero di pagina in cui compaiono. La ricerca nell’indice permette di consultare un elenco di indirizzi, in questo caso numeri di pagina, e di utilizzare questi ultimi per individuare un termine nel testo cercandolo alle pagine specificate. L’alternativa, se non ci fosse l’indice, sarebbe esaminare lentamente tutto il volume, parole per parola, per trovare il termina a cui si è interessati; quest’operazione corrisponde a eseguire una ricerca lineare su un file.Per un file con una data struttura di record che consiste di parecchi campi (o attributi), la struttura di accesso a indice di solito è definita su un unico campo, chiamato campo di indicizzazione (oppure attributo di indicizzazione). L’indice di solito memorizza ogni valore del campo di indicizzazione corredandolo di un elenco di puntatori a tutti i blocchi del disco che contengono record con quel valore del campo. I valori dell’indice sono ordinati in modo che si possa eseguire una ricerca binaria. Il file dell’indice è ovviamente molto più piccolo rispetto al file dei dati, quindi una ricerca binaria è ragionevolmente efficace. L’indicizzazione a più livelli evita la necessità di una ricerca binaria, ma richiede la creazione di ulteriori indici all’indice stesso. Esistono molti tipi di indici ordinati. L’indice primario è specificato sul campo chiave di ordinamento di un file ordinato di record. Come si è detto in precedenza, il campo chiave di ordinamento è utilizzato per ordinare fisicamente i record dei file su disco e tutti i record hanno un valore univoco per quel campo. Se il campo di ordinamento non è un campo chiave, cioè se molti record nel file possono avere lo stesso valore del campo di ordinamento, può essere usato un altro tipo di indice chiamato indice di cluster. Si noti che un file può avere al massimo un campo di ordinamento fisico, quindi può avere al massimo un indice primario oppure un indice di cluster, ma non entrambi. Su qualsiasi campo non di ordinamento di un file può essere specificato un terzo tipo di indice detto indice secondario.

## Indici primari

Un indice primario è un file ordinato i cui record sono di lunghezza fissa e sono costituiti da due campi. Il primo campo è dello stesso tipo di dati del campo chiave di ordinamento, chiamato chiave primaria, del file di dati e il secondo campo è un puntatore a un blocco del disco (un indirizzo di blocco). Esiste una voce (o record dell’indice) nel file dell’indice per ogni blocco nel file di dati. Ogni voce è composta da due campi che contengono il valore del campo della chiave primaria del primo record del blocco e un puntatore al corrispondente blocco su disco. Il numero complessivo di voci dell’indice è uguale al numero di blocchi su disco nel file di dati ordinato. Il primo record in ciascun blocco del file di dati è chiamato record àncora del blocco o semplicementepunto àncora. Gli indici di questo tipo possono essere densi o sparsi: un indice denso contiene una voce per ogni valore della chiave di ricerca (e quindi ogni record) nel file di dati; un indice sparso (o non denso) contiene voci solo per alcuni valori di ricerca. L’indice primario è quindi un indice non denso (sparso), poiché include una voce per ogni blocco del file di dati piuttosto che per ogni valore di ricerca o per ogni record.Il file indice di un indice primario occupa meno blocchi rispetto al file dei dati per due motivi. Prima di tutto, vi sono meno voci che record nel file di dati. In secondo luogo, ogni voce normalmente è di dimensioni inferioririspetto a un record di dati perché ha solo due campi; di conseguenza un blocco su disco può contenere più voci dell’indice che record di dati. Una ricerca binaria nel file dell’indice richiede quindi meno accessi al blocco rispetto a una ricerca binaria nel file di dati.Un record il cui valore della chiave primaria è K si trova nel blocco il cui indirizzo è P(i), tale che K(i) ≤ K < K (i + 1). Il blocco i-esimo del file di dati contiene tutti questi record a causa dell’ordinamento fisico dei suoi record rispetto al campo della chiave primaria. Per recuperare un record, dato il valore K della chiave primaria, si esegue una ricerca binaria nel file dell’indice per trovare la voce i corrispondente dell’indice e poi si prende il blocco del file di dati il cui indirizzo è P(i).Un problema serio che si verifica con l’indice primario, così come con qualsiasi file ordinato, è l’inserimento e l’eliminazione dei record. Nel caso dell’indice primario la questione è più grave perché, se si tenta di inserire un record nella sua posizione corretta nel file di dati, si devono non solo spostare gli altri record per creare spazio per quello nuovo, ma anche cambiare alcune voci dell’indice, perché lo spostamento dei record modificherà i punti di aggancio di alcuni blocchi.

## Indici di cluster

Se i record di un file sono ordinati fisicamente rispetto a un campo che non è chiave, cioè che non ha un valore distinto per ciascun record, quel campo è chiamato campo di raggruppamento. È possibile creare un apposito tipo di indice, detto indice di cluster, per velocizzare il recupero dei record che hanno lo stesso valore del campo di raggruppamento. Questo indice differisce da un indice primario, che richiede che il campo di ordinamento del file di dati abbia un valore distinto per ogni record. Anche l’indice di cluster è un file ordinato con due campi: il primo è dello stesso tipo del campo di raggruppamento del file di dati, mentre il secondo è un puntatore a un blocco. Vi è una voce nell’indice di cluster per ogni valore distinto del campo di raggruppamento, la quale contiene il valore del campo e un puntatore al primo blocco nel file di dati che contiene un record con quel valore del campo di raggruppamento. Si noti che l’inserimento e l’eliminazione dei record causano ancora dei problemi perché i record dei dati sono fisicamente ordinati. Per ridurre il problema dell’inserimento è possibile riservare un intero blocco (oppure un raggruppamento di blocchi contigui) per ciascun valore del campo di raggruppamento; tutti i record con quel valore del campo sono posti nel blocco (o raggruppamento di blocchi). Questo rende l’inserimento e l’eliminazione relativamente semplici.Un indice di cluster è un altro esempio di indice non denso, perché contiene una voce per ogni valore distinto del campo di indicizzazione piuttosto che per ogni record nel file.

## Indici secondari

Un indice secondario è anch’esso un file ordinato con due campi. Il primo campo è dello stesso tipo di dati di un campo del file di dati, che non viene utilizzato per effettuare l’ordinamento del file di dati, chiamato campo di indicizzazione. Il secondo campo è un puntatore a blocco oppure un puntatore a record. Vi possono essere più indici secondari (e quindi campi di indicizzazione) per lo stesso file.Si prenda in considerazione prima di tutto una struttura di accesso del tipo indice secondario su un campo chiave che un valore distinto per ciascun record. Un campo di questo tipo talvolta è chiamato chiave secondaria. In questo caso vi è una voce dell’indice per ciascun record del file di dati, la quale contiene il valore della chiave secondaria del record e un puntatore al blocco in cui il record è memorizzato oppure al record stesso. Questo indice, quindi, è denso.Si indica nuovamente i valori dei due campi di una voce i con <K(i), P(i)>. Le voci sono ordinate rispetto al valore di K(i), quindi si può eseguire una ricerca binaria. Visto che i record del file di dati non sono fisicamente ordinati rispetto ai valori del campo della chiave secondaria, non è possibile utilizzare i punti àncora dei blocchi. Questo perché viene creata una voce dell’indice per ciascun record nel file di dati invece che per ogni blocco come nel caso di un indice primario. Un indice secondario di solito ha bisogno di più spazio di memorizzazione e di un tempo di ricerca più lungo rispetto a un indice primario a causa del suo maggiore numero di voci. Il miglioramento nel tempo di ricerca di un record arbitrario, tuttavia, è decisamente maggiore per un indice secondario che per un indice primario, visto che se l’indice secondario non esistesse si dovrebbe svolgere una ricerca lineare nel file di dati. Nel caso dell’indice primario, invece, si potrebbe eseguire una ricerca binaria sul file principale, anche se l’indice non esistesse. Una ricerca binaria su questo indice secondario richiede [ (log2bi) ] = [ (log2442) ] = 9 accessi di blocchi. Per cercare un record usando l’indice è indispensabile un ulteriore accesso a blocco del file di dati per un totale di 9 + 1 = 10 accessi, un enorme miglioramento rispetto ai 1500 accessi mediamente necessari per una ricerca lineare, ma leggermente peggiore dei sette accessi necessari usando l’indice primario.Si può creare anche un indice secondario su un campo non chiave di un file. In questo caso numerosi record nel file di dati possono avere lo stesso valore del campo di indicizzazione. Si noti che un indice secondario fornisce un ordinamento logico dei record attraverso il campo di indicizzazione. Se si accede ai record secondo l’ordine delle voci dell’indice secondario, li si ottiene nell’ordine del corrispondente campo di indicizzazione. 

## Indici multilivello

Gli schemi d’indicizzazione descritti finora richiedono che il file dell’indice sia ordinato. Si usa la ricerca binaria per individuare i puntatori a un blocco sul disco oppure a un record (o ai record) nel file che ha il valore specificato del campo di indicizzazione. La ricerca binaria richiede approssimativamente (log2bi) accessi ai blocchi per un indice con bi blocchi, perché ogni passo dell’algoritmo riduce la parte dell’indice in cui si deve continuare a cercare di un fattore pari a 2. Questo spiega perché si considera la funzione logaritmo in base 2. L’idea che sta alla base di un indice multilivello è ridurre a ogni passo la parte dell’indice in cui si continua a cercare di un fattore bfri, il fattore di blocco dell’indice, che è maggiore di 2. Lo spazio di ricerca, quindi, viene ridotto molto più velocemente. Il valore bfri è chiamato il fan-out dell’indice multilivello e si farà riferimento ad esso col il simbolo fo. La ricerca in un indice multilivello richiede approssimativamente (logfobi) accessi ai blocchi, che è un numero inferiore rispetto a quello della ricerca binaria se il fan-out è maggiore di 2. Un indice multilivello considera il file dell’indice, al quale si fa riferimento ora come indice di primo livello (o livello base) di un indice multilivello, come un file ordinato con un valore distinto per ogni K(i). A questo punto è possibile creare un indice primario per l’indice di primo livello; questo indice dell’indice di primo livello è detto secondo livello dell’indice multilivello. Poiché il secondo livello è un indice primario, si possono utilizzare i punti àncora dei blocchi in modo che il secondo livello contenga una voce per ciascun blocco del primo livello. Il fattore di blocco bfri, per il secondo livello, e per tutti i livelli successivi, è lo stesso dell’indice di primo livello, perché tutte le voci dell’indice hanno la medesima dimensione; ciascuna ha un valore del campo e un indirizzo del blocco. Se il primo livello ha r1 voci e il fattore di blocco, che è anche il fan-out, è bfri = fo, il primo livello necessita di [ (r1/fo) ] blocchi, che è quindi il numero di voci r2 necessarie al secondo livello dell’indice. Si può ripetere questo procedimento per il secondo livello. Il terzo livello, che è un indice primario per l’indice di secondo livello, ha una voce per ogni blocco del secondo livello; il numero delle voci del terzo livello è quindi r3 = [ (r2/fo) ]. Si noti che è richiesto un secondo livello solo se il primo necessita di più di un blocco di disco e, in modo simile, è richiesto un terzo livello solo se il secondo occupa più di un blocco. Si può ripetere il procedimento precedente finché tutte le voci di un livello t dell’indice possono essere contenute in un singolo blocco. Questo blocco di livello t-esimo viene chiamato livello superiore dell’indice. Ogni livello riduce il numero di voci del livello precedente di un fattore di fo, il fan-out dell’indice, cosicché è possibile usare la formula 1 ≤ (r1/((fo)t)) per calcolare t. Quindi un indice multilivello con r1 voci del primo livello avrà approssimativamente t livello, dove t = [ (logfo(r1)) ].Lo schema multilivello qui descritto può essere usato su qualsiasi tipo di incide, cioè primario, di cluster, o secondario, purché l’indice di primo livello abbia valori distinti per K(i) e voci di lunghezza fissa. Come si è visto, un indice multilivello riduce il numero degli accessi a blocchi durante la ricerca di un record, per un dato valore del campo di indicizzazione. Occorre ancora affrontare i problemi di gestione delle eliminazioni e degli inserimenti nell’indice, perché tutti i livelli dell’indice sono file fisicamente ordinati. Per mantenere i vantaggi dell’utilizzo dell’indicizzazione multilivello senza incorrere nei problemi di eliminazionee di inserimento, i progettisti hanno adottato un tipo di indice multilivello che lascia dello spazio libero in ciascuno dei suoi blocchi per l’immissione di nuove voci. Questo è detto indice dinamico multilivello ed è spesso implementato usando le strutture di dati chiamate alberi B e alberi B+ descritti successivamente. 

### Indici multilivello e alberi di ricerca

Gli alberi B e gli alberi B+sono casi speciali degli alberi della ben nota struttura di dati. Si presenta qui di seguito molto brevemente la terminologia usata nella loro descrizione. Un albero è formato da nodi. Ogni nodo, tranne uno speciale chiamato radice, ha un padre e zero o più nodi figlio. La radice non ha il nodo padre. Un nodo che non ha alcun nodo figlio è chiamato foglia; un nodo che non è foglia è un nodo interno. Il livello di un nodo è sempre superiore di una unità rispetto al livello del suo nodo padre, mentre il livello del nodo radice è zero. Un sottoalbero di un nodo è costituito da quel nodo e da tutti i suoi nodi discendenti, i suoi nodi figli, i nodi figli dei suoi nodi figli e così via. Una precisa definizione ricorsiva di un sottoalbero dice che un sottoalbero è costituito da un nodo n e dai sottoalberi di tutti i nodi figli n. Di solito si visualizza un albero con il nodo radice posto nella parte superiore. Un modo per implementare un albero è inserire in ciascun nodo tanti puntatori quanti sono i nodi figli di quel nodo. In alcuni casi in ciascun nodo è anche memorizzato un puntatore al padre. Oltre ai puntatori, un nodo di solito contiene qualche tipo di informazioni. Quando un indice multilivello viene implementato come albero, le informazioni includono i valori del campo di indicizzazione usati per guidare la ricerca di un particolare record.

Un albero di ricerca è un tipo di albero speciale che viene usato per guidare la ricerca di un record, dato il valore di uno dei suoi campi. Gli indici multilivello trattati in precedenza possono essere pensati come una variante di un albero di ricerca: ogni nodo dell’indice multilivello può avere fino a fo puntatori e fo valori chiave, dove fo è il fan-out dell’indice. I valori dei campi dell’indice di ciascun nodo guidano l’utente al nodo successivo finché raggiunge il blocco del file di dati che contiene i record richiesti. Seguendo un puntatore si limita a ogni passo la ricerca a un sottoalbero dell’albero di ricerca e si ignorano tutti i nodi che non sono di quel sottoalbero. Alberi di ricerca. Un albero di ricerca è leggermente differente da un indice multilivello. Un albero di ricerca di ordine p è un albero tale che ogni suo nodo contiene al massimo p – 1 valori di ricerca e i p puntatori sono nell’ordine <P1, K1, P2, K2, …, Pq-1, Kq-1, Pq >, in cui q ≤ p; ogni Pi è un puntatore a un nodo figlio (oppure è un puntatore vuoto) e ogni Ki è un valore di ricerca preso da un insieme ordinato di valori. Si può usare un albero di ricerca come meccanismo per ricercare i record immagazzinati in un file su disco. I valori nell’albero possono essere i valori di uno dei campi del file chiamato campo di ricerca (che equivale al campo di indicizzazione se un indice multilivello viene utilizzato per guidare la ricerca). Ogni valore chiave dell’albero è associato a un puntatore al record nel file di dati che ha quel valore. In alternativa il puntatore può puntare al blocco del disco che contiene quel record. Lo stesso albero di ricerca può essere memorizzato su disco assegnando ogni nodo dell’albero a un blocco del disco. Quando viene inserito un nuovo record si deve aggiornare l’albero di ricerca inserendo nell’albero una voce contenete il valore del campo di ricerca del nuovo record e un puntatore al nuovo record.Nuovi algoritmi sono necessari per inserire e cancellare i valori di ricerca nell’albero di ricerca, mentre si continuano a rispettare i due vincoli precedenti. In generale questi algoritmi non garantiscono che un albero di ricerca sia bilanciato, cioè che tutti i suoi nodi foglia siano allo stesso livello. Mantenere un albero di ricerca bilanciato è importante, perché ciò garantisce che nessun nodo si troverà a livelli molto alti e quindi richiederà molti accessi ai blocchi durante la ricerca. Un altro problema con gli alberi di ricerca è che l’eliminazione dei record possa lasciare alcuni nodi nell’albero quasi vuoti, sprecando quindi spazio per la memorizzazione e aumentando il numero dei livelli. La tecnica degli alberi B affronta entrambi questi problemi specificando ulteriori vincoli sull’albero di ricerca.

### B-Tree

L’albero B soddisfa ulteriori vincoli che assicurano che l’albero sia sempre bilanciato e che lo spazio sprecato a seguito di cancellazione, se ce n’è, non diventi mai eccessivo. Gli algoritmi per l’inserimentoe la cancellazione, però, diventano più complessi allo scopo di soddisfare questi vincoli. Ciononostante, in genere gli inserimenti e le cancellazioni sono processi semplici; diventano complicati solo in particolari circostanze, cioè ogni volta che si tenta un inserimento in un nodo che è già completo oppure una cancellazione da un nodo che così diventa più della metà vuoto. Un albero B inizia con un solo nodo radice (che è anche un nodo foglia) a livello 0. Quando il nodo radice diventa completo e con p – 1 valori della chiave di ricerca e si tenta di inserire un’altra voce nell’albero, il nodo radice si divide in due nodi di livello 1. Solo il valore centrale è tenuto nel nodo radice, mentre il resto dei valori sono divisi equamente tra gli altri due nodi. Quando uno dei nodi non radice è completo e una nuova voce dovrebbe esservi inserita, il nodo è diviso in due nodi dello stesso livello e la voce centrale è spostata verso il nodo padre insieme ai due puntatori ai nuovi nodi ottenuti dalla divisione. Se il nodo padre è completo viene diviso anch’esso. La divisione può propagarsi per tutto il tragitto verso il nodo radice, creando un nuovo livello se anche la radice deve essere divisa.Se la cancellazione di un valore fa sì che un nodo sia completo per meno della metà, viene fuso con i suoi nodi vicini; anche questa fusione può propagarsi lungo tutto il tragitto verso la radice. La cancellazione, quindi, può ridurre il numero dei livelli dell’albero. È stato mostrato attraverso l’analisi e la simulazione che, dopo numerosi inserimenti e cancellazione casuali in un albero B, i nodi sono approssimativamente completi al 69% quando il numero dei valori nell’albero si stabilizza. Questo valeanche per gli alberi B. Se ciò avviene, la divisione e l’unione dei nodi si verificano solo raramente, quindi l’inserimento e la cancellazione diventano abbastanza efficaci. Se il numero dei valori aumenta ancora, l’albero si espanderà senza problemi, anche se si può verificare la divisione dei nodi e così alcuni inserimenti richiederanno più tempo. Gli alberi B sono usati talvolta come organizzazione del file di dati. In questo casotutti i record sono memorizzati all’interno dei nodi dell’albero B invece che solo le voci <chiave di ricerca, puntatore del record>. Questo funziona bene per i file con un numero relativamente piccolo di record e una dimensione ridotta del record, altrimenti il fan-out e il numero di livelli diventano troppo grandi per permettere un accesso efficace.Riassumendo, gli alberi B forniscono una struttura di accesso multilivello che produce un albero bilanciato in cui ogni nodo è riempito almeno per metà. Ciascun nodo di un albero B di ordine p può avere al massimo p – 1 valori di ricerca.

### B+Tree

La maggior parte delle odierne implementazioni di indici multilivello dinamici utilizza una variante della struttura di dati ad albero B, chiamata albero B+. In un albero B, tutti i valori del campo di ricerca appaiono una volta a un dato livello nell’albero, insieme a un puntatore ai dati. In un albero B+i puntatori ai dati sono memorizzati solo nei nodi foglia dell’albero; quindi la struttura dei nodi foglia differisce dalla struttura dei nodi interni. I nodi foglia contengono una voce per ogni valore del campo di ricerca, insieme a un puntatoreal record dei dati (oppure al blocco che contiene questo record) se il campo di ricerca è un campo chiave. Per un campo di ricerca non chiave, il puntatore fa riferimento a un blocco che contiene i puntatori ai record del file di dati, creando un livello ulteriore di indici. I nodi foglia dell’albero B+ di solito sono collegati tra loro per fornire un accesso ordinato al campo di ricerca e ai record. Questi nodi foglia sono simili al primo livello (base) di un indice. I nodi interni dell’albero B+corrispondono agli altri livelli di un indice multilivello. Alcuni valori del campo di ricerca dai nodi foglia sono ripetuti nei nodi interni dell’albero B+ per guidare la ricerca. I puntatori nei nodi internisono puntatori a un albero di blocchi che sono nodi dell’albero, mentre i puntatori nei nodi foglia sono puntatori ai dati che fanno riferimenti ai record o ai blocchi del file di dati, a eccezionedel puntatore Psuccessivo che è un puntatore a un albero del successivo nodo esterno. Iniziando dal nodo foglia più a sinistra è possibile attraversare i nodi foglia come se fossero una lista concatenata, usando i puntatori Psuccessivo. Questo fornisce un accesso ordinato ai record di dati basato sul campo di indicizzazione. Può essere incluso anche un puntatore Pprecedente. Per un albero B+su un campo non chiave, è necessario un livello ulteriore di indici, così che i puntatori Pr sono puntatori ai blocchi che contengono un insieme di puntatori ai record effettivi del file di dati, come specificato nell’opzione 3 del paragrafo precedente.Poiché le voci nei nodi interni di un albero B+includono valori di ricerca e puntatori a un albero senza alcun puntatore ai dati, un nodo interno di un albero B+ può contenere più voci del nodo corrispondente di un albero B. A parità di dimensione del blocco (nodo), l’ordine p sarà più grande per un albero B+rispetto a un albero B, come illustrato nell’Esempio 6. Questo fa sì che l’albero B+ abbia meno livelli, migliorando il tempo di ricerca. Poiché le strutture dei nodi interni e foglia di un albero B+sono diverse, l’ordine p può essere differente nei due casi. Si userà p per denotare l’ordine dei nodi interni e pfoglia per denotare l’ordine dei nodi foglia e definito come il numero massimo dei puntatori ai dati presenti in un nodo foglia. Anche nel caso dell’albero B+, può essere necessario che ogni nodo contenga ulteriori informazioni per implementare gli algoritmi d’inserimento e di cancellazione. Queste informazioni possono comprendere il tipo di nodo (interno o foglia), il numero di voci q correnti del nodo e i puntatori ai nodi padre e fratelli. Prima di eseguire i calcoli precedenti per p e pfoglia, quindi, si dovrebbe ridurre la dimensione del blocco della quantità di spazio necessario per contenere tutte queste informazioni. Per quanto concerne l'inserimento e la cancellazione con alberi B+... Prima di tutto si osservi che la radice è l’unico nodo nell’albero, quindi è anche un nodo foglia. Non appena si crea più di un livello, l’albero viene diviso in nodi interni e foglia. Si noti che ogni valore chiave deve esistere a livello delle foglie, perché tutti i puntatori ai dati si trovano a livello delle foglie. Tuttavia, solo alcuni valori sono presenti nei nodi interni per guidare la ricerca. Si consideri anche che ogni valore che appare in un nodo interno compare anche come il valore più a destra tra i nodi foglia del sottoalbero a cui fa riferimento il puntatore all’albero posto a sinistra del valore.Quando un nodo foglia è completo e viene inserita una nuova voce, il nodo trabocca (overflow) e il suo contenuto viene diviso in due. Le prime j = [ ((pfoglia + 1)/2) ] voci del nodo originale sono mantenute in questo stesso nodo, mentre le restanti voci sono spostate in un nuovo nodo foglia. Il valore di ricerca j-esimo è replicato nel nodo interno padre e un ulteriore puntatore al nuovo nodo è creato nel padre. Questi valori devono essere inseriti nel nodo padre nella sequenza corretta. Se il nodo interno padre è completo, il nuovo valore gli causerà un trabocco, quindi anch’esso dovrà essere diviso in due. Le voci nel nodo interno fino a Pj, il puntatore a un albero j-esimo dopo l’inserimento del nuovo valore e del puntatore, con j = [ (p + 1)/2 ], sono mantenuti, mentre il valore di ricerca j-esimo è spostato nel padre, ma non ripetuto. Un nuovo nodo interno conterrà le voci rimanenti da Pj+1 in poi. Questa divisione può propagarsi lungo tutto il tragitto fino a creare un nuovo nodo radice e quindi un nuovo livello dell’albero B+. Quando una voce è cancellata, è sempre rimossa dal livello delle foglie. Se capita che si trovi in un nodo interno, deve essere eliminata anche da lì. In questo caso il valore alla sua sinistra nel nodo foglia deve sostituirla nel nodo interno, perché quel valore ora è la voce più a destra nel sottoalbero. La cancellazione può causare uno svuotamento riducendo il numero di voci nel nodo foglia sotto il minimo richiesto. In questo caso si cerca di trovare un nodo foglia fratello, cioè un nodo esterno esattamente a sinistra o a destra del nodo con lo svuotamento, e di ridistribuire le voci tra il nodo e suo fratello in modo che entrambi siano almeno completi a metà; altrimenti il nodo è fuso con i suoi fratelli e il numero di nodi foglia si riduce. Un metodo comune è provare a ridistribuire le voci nel fratello a sinistra; se non è possibile, viene fatto un tentativo di ridistribuzione con il fratello a destra. Se anche questo non è possibile, i tre nodi vengono fusi ottenendo due nodi esterni. In questo caso lo svuotamento può propagarsi ai nodi interni perché sono necessari un puntatore a un albero e un valore di ricerca in meno. Questo effetto può propagarsi e ridurre i livelli dell’albero.
