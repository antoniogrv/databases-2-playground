# Database Distribuiti

I DDB uniscono le tecnologie di reti e basi di dati. Utilizzare un DBD consenti alle organizzazioni di decentralizzare le informazioni, integrando le informazioni a livello logico. Un database distribuito è un singolo database logico che è sparso fisicamente attraverso computer in località differenti e connessi attraverso la rete. Usa DDBMS multipli, ognuno su un sito remoto (nodo). Vanta eterogeneità HW e SW. Gli ambienti di database distribuiti si differenziano in base al grado di cooperazione fra DDBMS e la presenza di un sito master che coordini le richeiste che coinvoglono le informazioni memorizzate. Ottimizzazione delle query. La modalità di esecuzione è seriale e parallela (seriale = client interroga master che interroga i nodi; parallela = client interroga le repliche).

I vantaggi di un DDB partono dai livelli di trasparenza:
- **Di locazione**: accedo ai dati a prescindere da dove si trovano
- **Di naming**: uso un nome logico senza referenziare posizione fisica
- **Di replica**: accedo ai dati senza sapere in che formula sono replicati
- **Di frammentazione orizzontale e verticale**: accedo ad uno schema e alle tuple che mi interessano al di là di come sono frammentate

Altri vantaggi sono affidabilità e disponibilità. Quando un sito fallisce, gli altri nodi continuano ad operare. E' più facile scalare: miglioramento delle prestazioni. Localizzazione dei dati e relativa migrazione rende più veloce l'accesso alle informazioni dalla rete. Un DDBMS deve garantire la tracciabilità dei dati, la robustezza delle transazioni distribuite, la gestione del recovery e come dev'essere distribuito e frammentato il catalogo.

Il Design dei DDB prevede l'applicazione di tecniche relative alla frammentazione, replicazione e allocazione dei frammenti.

Con segmentazione orizzontale intendiamo una frammentazione orizzontale fra tuple logicamente correlate. Esiste anche la frammentazione mista.

- Uno schema di frammentazione di un database è la definizione di un insieme di frammenti che include tutte le tuple e gli attributi del database. Esso, inoltre, consente la ricostruzione dell’intero database applicando una sequenza di operazioni di OUTER JOIN e UNION.
- Lo schema di allocazione descrive l’allocazione dei frammenti ai siti del database. Associa ad ogni frammento il sito in cui deve essere memorizzato. Un frammento memorizzato su più di un sito si dice replicato.
- Lo schema di replicazione è una descrizione della replicazione dei frammenti. Ogni segmento deve essere assegnato ad un sito del database, e questo processo porta il nome di allocazione dei dati. La scelta dei siti e del grado di replicazione dipende da:
• Prestazioni.
• Obiettivi di disponibilità del sistema.
• Tipo e frequenza delle transazioni sottomesse ad ogni sit

La replicazione consente di migliorare la disponibilità dei dati. 
Le modalità di replicazione sono le seguenti:
• Replicare l’intero database in ogni sito, migliora le prestazioni per le query. L’overhead risulta essere eccessivo per l’aggiornamento dei dati e il controllo della concorrenza e recovery sono complessi.
• Nessuna replicazione, frammenti disgiunti (eccetto per la chiave).
• Replicazione parziale, una soluzione intermedia, dove alcuni frammenti possono essere replicati ed altri no.

Trovare una soluzione ottima alla distribuzione dei dati è un problema difficile. Se è richiesta un’alta disponibilità e le transazioni possono essere sottomesse ad ogni sito e molte transazioni sono solo di retrieval, si può adottare una soluzione di replicazione totale.Se alcune transazioni che accedono a porzioni del database sono sottomesse solo da particolari siti, su quei siti possono essere allocati i frammenti corrispondenti. Se sono richiesti molti aggiornamenti è conveniente ridurre la replicazione dei dati. 

Le modalità/livelli per esprimere interrogazioni offerte dai DBMS commerciali sono:
• FRAMMENTAZIONE. Il programmatore non si deve preoccupare se o no il database è distribuito o frammentato.
• ALLOCAZIONE. Il programmatore dovrebbe conoscere la struttura dei frammenti, ma non deve indicare la loro allocazione.
• LINGUAGGIO. Il programmatore deve indicare nella query sia la struttura dei frammenti che la loro allocazione

I DDB si differenziano in base a diversi fattori:
• Grado di omogeneità del software dei DDBMS, dove:
o DDB omogenei: tutti i server e tutti gli utenti usano lo stesso software.
o DDB eterogenei, altrimenti. 
• Grado di autonomia locale, dove:
o Se il sito locale non può funzionare come un DBMS stand-alone non ha nessuna autonomia locale, e all’utente il sistema “appare” come un DBMS centralizzato. 
o Se alle transazioni locali è permesso l’accesso diretto a un server, ha qualche grado di autonomia locale.

## Concorrenza e Recovery nei DDB

I database distribuiti incontrano un numero di controlli di concorrenza e problemi di recovery che non sono presenti nei database centralizzati. Ne vengono elencati alcuni di seguito:
• Trattamento di copie multiple di dati. Il controllo della consistenza deve mantenere una consistenza globale. Allo stesso modo il meccanismo di recovery deve recuperare tutte le copie e conservare la consistenza dopo il recovery. 
• Fallimenti di singoli siti. La disponibilità del database non deve essere influenzata dai guasti di uno o due siti e lo schema di recovery li deve recuperare prima che siano resi disponibili. 
• Guasto dei collegamenti di comunicazione. Tale guasto può portare ad una partizione della rete che può influenzare la disponibilità del database anche se tutti i siti sono in esecuzione. 
• Commit distribuito. Una transazione può essere frammentata ed essere eseguita su un numero di siti. Questo richiede un approccio basato sul commit a due fasi per il commit della transazione.
• Deadlock distribuito. Poiché le transazioni sono processate su siti multipli, due o più siti possono essere coinvolti in un deadlock. Di conseguenza devono essere considerate le tecniche per il trattamento dei deadlock. 
• Controllo della concorrenza distribuito basato su una copia designata dei dati. Si designa una particolare copia di ogni dato (copia designata). Tutte le richieste di lock ed unlock vengono inviate 
solo al sito che la contiene.
• Tecnica del sito primario. Un singolo sito è designato come sito primario il quale fa da coordinatore per la gestione delle transazioni. 

Tecnica del sito primario:
Nell’ottica della gestione delle transazioni il controllo della concorrenza ed il commit sono gestiti da questo sito. La tecnica del lock a due fasi (2PL) è usata per bloccare e rilasciare i data item. Se tutte le transazioni in tutti i siti seguono la politica delle due fasi allora viene garantita la serializzabilità. 
Vantaggi: i data item sono bloccati (locked) solamente in un sito ma possono essere usati da qualsiasi altro sito.
Svantaggi: tutta la gestione delle transazioni passa per il sito primario che potrebbe essere sovraccaricato. Nel caso in cui il sito primario fallisce, l’intero sistema è inaccessibile. Per assistere il recovery, un sito di backup viene designato come copia di backup del sito primario. Nel caso di fallimento del sito primario, il sito di backup funziona da sito principale. 

Tecnica della copia primaria:
In questo approccio, invece di un sito, una partizione dei data item è designata come copia primaria. Per bloccare un data item soltanto sulla copia primaria di quel data item viene eseguito il lock. 
Vantaggi: le copie primarie sono distribuite su vari siti, e un singolo sito non viene sovraccaricato da un numero elevato di richieste di lock ed unlock. 
Svantaggi: l’identificazione della copia primaria è complesso. Una directory distribuita deve essere gestita possibilmente in tutti i siti.

Recovery dal fallimento di un coordinatore:
In entrambi gli approcci un sito coordinatore o un sito copia possono essere indisponibili. Questo richiede la selezione di un nuovo coordinatore. 
• Approccio del sito primario senza sito di backup. Abortire e far ripartire tutte le transazioni attive in tutti i siti. Si elegge un nuovo coordinatore che inizia il processing delle transazioni.
• Sito primario con copia di backup. Sospende tutte le transazioni attive, designa il sito di backup come sito primario e identifica un nuovo sito di backup. Il nuovo sito primario riceve il compito di gestire tutte le transazioni per riprendere il processo. Se il sito primario e quello di backup falliscono si utilizza un processo di elezione per selezionare un nuovo sito coordinatore.

Controllo della concorrenza basata sul Voting:
In questo caso non esiste la copia primaria del coordinatore. Quindi:
1. Spedire una richiesta di lock ai siti che hanno i data item.
2. Se la maggioranza dei siti concedono il lock allora la transazione richiedente ottiene il data item.
3. Le informazioni di lock (concesse o negate) sono spedite a tutti questi siti.
4. Per evitare un tempo di attesa inaccettabile, viene definito un periodo di time-out. Se la transazione richiedente non riceve alcuna informazione di voto allora la transazione viene abortita.

# Database NoSQL

RDBMS è l’acronimo di relational database management system e indica un database management system basato sul modello relazionale. 

Le motivazioni alla base dell’utilizzo di un RDBMS sono:
- Schema predefinito per lo storage di dati strutturati;
- Struttura BCNF già familiare;
- Strong consistency;
- Gestione delle transazioni;
- Maturi e accuratamente testati;
- Facile adozione/integrazione;
- Basati sulle proprietà ACID;
- SQL è versatile e potente;

Cosa ha spinto a database NoSQL:
- BIG USERS: un gran numero di utenti combinato con pattern di gestione dei dati fortemente dinamici, stando guidando il bisogno di nuovi database scalabili. Con le tecnologie relazionali, è difficile raggiungere la scalabilità dinamica richiesta dalle applicazioni per garantire il livello di performance 
richiesto dagli utenti;
- BIG DATA: la rapida crescita dell’ammontare dei dati e la natura degli stessi.

I database NoSQL possono avere le caratteristiche più disparate: alcuni non utilizzano il modello relazionale, altri usano tabelle e campi ma senza schemi fissi, alcuni non permettono vincoli di integrità referenziale, altri non garantiscono transazioni ACID, oppure ci sono varianti che combinano le precedenti. Alcuni database NoSQL garantiscono solo alcune proprietà ACID. Per esempio, non sempre è garantita la consistenza (si parla in questo caso di eventual consistency), ossia ci può essere una certa latenza prima che una modifica al database sia visibile. Altri non garantiscono la durabilità: ad esempio, in alcuni database distribuiti il malfunzionamento di un nodo dopo una transazione potrebbe impedire la corretta sincronizzazione di tutta la rete.Queste proprietà vengono rilassate per fornire performance migliori.

I NoSQL si basano sul modello BASE:
- Basically Available: garantire la disponibilità dei dati anche in presenza di fallimenti multipli. L’obiettivo è raggiunto attraverso un approccio fortemente distribuito;
- Soft State: abbandonano il requisito della consistenza dei modelli ACID quasi completamente. La consistenza è un problema dello sviluppatore e non deve essere gestita dal database.
- Eventual Consistency: l’unico requisito riguardante la consistenza è garantire che, ad un certo momento, nel futuro, i dati possano convergere ad uno stato consistente.

Un sistema distribuito è in grado di supportare solamente due tra le seguenti caratteristiche:
- Consistency: tutti i nodi vedono lo stesso dato nello stesso tempo;
- Availability: ogni operazione deve sempre ricevere una risposta;
- Partition tolerance: capacità di un sistema di essere tollerante al partizionamento

I vantaggi dell'usare un database NoSQL sono:
- Strutturazione dei dati: maggiore centralità alle informazioni e alla loro varietà, supportando l’uso di dati non omogenei pur mantenendo le possibilità di interrogazione, analisi ed elaborazione efficiente;
- Scalabilità: i database NoSQL sono generalmente basati su strutture fisiche che si prestano meglio alla distribuzione dei dati su più nodi di una rete (sharding), permettendone un’espandibilità maggiore;
- Prestazioni: la maggiore distribuzione dei dati sulle reti permette migliori performance;
- Flessibilità nella progettazione: la struttura flessibile usata nei database NoSQL non obbliga ad una stereotipazione dei dati durante la progettazione.

Gli svantaggi dell'usare un database NoSQL sono:
- Maturità: i sistemi RDBMS sono in esercizio da tanto tempo;
- Supporto: tutte le aziende che sviluppano e vendono RDBMS forniscono un alto livello di supporto alle aziende
- Business intelligence: spesso i tool per la BI non supportano connettività con i database NoSQL;
- Amministrazione: al giorno d’oggi sono necessarie grosse competenze per l’installazione e manutenzione dei database NoSQL;
- Un altro noto problema di quando si sviluppa con linguaggi orientati ad oggetti è il cosiddetto O/R impedance mismatch, ossia i due modelli, relazionale e ad oggetti, sono molto diversi tra loro (può generare problematiche quali il polimorfismo oppure la conversione dei tipi di dati).
- Carenza di tool
- Carenza di esperti DBA NoSQL

In genere, conviene utilizzare database NoSQL quando:
- La struttura dati non è definibile a priori;
- I dati disposti nei vari oggetti sono molto collegati tra loro;
- È necessario interagire molto frequentemente con il database;
- Si necessita di prestazioni più elevate.

I DBMS NoSQL possono essere classificati in quattro categorie:

**[DOCUMENT DATA STORE]**
- Utilizzano dati non strutturati;
- Schema–less;
- Supporto a diversi tipi di documento;
- Ogni documento è identificato da una chiave primaria
- Scalabilità orizzontale
La rappresentazione dei dati avviene attraverso strutture simili ad oggetti, dette documenti, ognuno dei quali possiede delle proprietà che rappresentano le informazioni. I documenti non devono seguire una struttura rigida fissa. Il documento può essere visto come l’equivalente di un record delle tabelle. I documenti possono essere messi in relazione tra loro con dei riferimenti.

**[KEY-VALUE DATA STORE]**
- Utilizza un associative array chiave–valore come modello per lo storage;
- Storage, update e ricerca basato sulle chiavi;
- Tipi di dati primitivi familiari ai programmatori;
- Semplice, veloce recupero dei dati;
- Grandi moli di dati;
Vengono costruiti come dizionari o mappe, in cui viene inserita una coppia chiave-valore.. Il loro utilizzo principale è offrire la possibilità di effettuare ricerche rapide di singoli blocchi di informazione. Sono database che puntano tutto sulla velocità.

**[GRAPH-BASED DATA STORE]**
- Utilizza nodi (entità), proprietà (attributi) e archi (relazioni);
- Modello logico semplice e intuitivo;
- Ogni elemento contiene un puntatore all’elemento adiacente;
- Attraversamento del grafo per trovare i dati;
- Efficiente per la rappresentazione di reti sociali o dati sparsi;
- Relazioni tra i dati centrali
Le informazioni possono essere custodite sia nei nodi che negli archi. La forza di questa tipologia è tutto l’insieme del valore informativo che si può estrapolare ricostruendo i percorsi attraverso il grafo.

**[COLUMN-ORIENTED DATA STORE]**
- I dati sono nelle colonne anziché nelle righe;
- Un gruppo di colonne è chiamato famiglia e vi è analogia con RDBMS;
- Le colonne possono essere facilmente distribuite;
- Scalabile e performante;
- Fault–tolerant.
La rapida aggregazione che permettono è stata apprezzata dai grandi produttori di motori di ricerca e Social Network (alcune delle principali soluzioni di questo tipo sono Cassandra, Big Table, SimpleDB).
