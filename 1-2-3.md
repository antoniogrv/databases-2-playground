# Anomalie

Esistono delle misure informali di qualità per la progettazione di uno schema di relazione:
1. SEMANTICA DEGLI ATTRIBUTI (no oscurità)
2. RIDUZIONE DEI VALORI RIDONDANTI NELLE TUPLE
	- Anomalie di inserimento (mettere nuovo DIP senza IMP; nuovo IMP senza DIP)
	- Anomalie di modifica (se cambio DIP a uno devo farlo per tutti)
	- Anomalie di cancellazione (se elimino ultimo IMP con DIP, perdo DIP)
3. RIDUZIONE DEI VALORI NULL NELLE TUPLE (problema spazio memoria; count/avg/sum..)
4. NON CONSENTIRE TUPLE SPURIE (rappresentano info sbagliata, non valida; cioè join non produce informazione originale corretta)


# Dipendenze Funzionali

Vincolo fra due insiemi di attributi in una base di dati.
Si valutino tutti gli n attributi della base di dati A1...An. Si immagini all'intera base dati come descritta da un unico schema di relazione universale R = A1...An.
Una dipendenza funzionale X -> Y tra due insiemi di attributi X e Y (sottoinsiemi di R) specifica un vincolo sulle tuple che possono formare uno stato di relazione r di R. Per ogni coppia di tuple t1 e t2 in r tali che t1[X] = t2[X], risulta t1[Y] = t2[Y]. X determina funzionalmente Y in uno schema di relazione R se e solo se, ogni volta che due tuple concordano sul valore di X, esse devono necessariamente concordare sul valore di Y.

Se un vincolo su R stabilisce che non ci possa essere più di una tupla con un dato valore per X in una generica istanza di relazione r(R), cioè X è una chiave candidata di R, ciò implica X -> Y per ogni possibile sottoinsieme Y di attributi di R. L'uso delle dipendenze funzionali è quello di descrivere ulteriormente uno schema di relazione R, tramite una specifica sui suoi vincoli che vale sempre. Estensioni di relazione r(R) che soddisfano i vincoli di dipendenza funzionale sono dette estensioni valide.

# Regole di Inferenza

Si indichi con F l'insieme di DF su R. Tipicamente, il progettista specifica le DF 'semanticamente evidenti'. Di solito ne sussistono molte altre che possono essere semanticamente dedotte o inferite dalle altri in F.

Una DF X -> Y è inferita da un insieme di dipendenze F specificate su R se X -> Y sussiste in ogni stato di relazione r che sia un'estensione valida di R, cioè ogni volta che r soddisfa tutte le dipendenze in F. La chiusura F+ di F è l'insieme di tutte le DF deducibili da F. Per determinare queste DF indotte in modo sistematico, esistono delle regole di inferenza. Nota: F |= X -> Y indica che X -> Y è stata inferita da F. Inoltre, X -> Y è banale se X sottoinsieme di Y.

- RI1 (regola riflessiva): se X ⊇Y, allora X → Y;
- RI2 (regola di arricchimento): {X → Y} |= XZ → YZ;
- RI3 (regola transitiva): {X → Y, Y → Z} |= X → Z;
- RI4 (regola di decomposizione, o di proiezione): {X → YZ} |= X → Y;
- RI5 (regola di unione, o additiva): {X → Y, X → Z} |= X → YZ;
- RI6 (regola pseudo-transitiva): {X → Y, WY → Z} |= WX → Z;

Ognuna può essere dimostrata. Le dimostrazioni delle prime tre vengono usate per le rimanenti. Armostrong ha dimostrato che RI1-RI2-RI3 sono corrette e complete. Corrette nel senso che, dato F su R, tutte le dipendenze deducibili sussistono in ogni stato di relazione r di R che soddisfa le dipendenze in F. Completo nel senso che, usando ripetutamente quelle regole per inferire ulteriori dipendenze, non se ne potranno dedurre di più. [Alg. pag 12 per determinare tutte le dipendenze inferite]

Un insieme di dipendenze E è coperta da un insieme di funzionali F se ogni DF in E è presente anche in F+, cioè se ogni dipendenza in E può essere inferita da F. Due insiemi E ed F di dipendenze funzionali sono equivalenti se E+ = F+.

# Forme Normali e Chiavi

Le DF sono fonte di informazione sulla semantica degli schemi di relazione. Il processo di normalizzazione sottopone uno schema di relazione a una serie di test per “certificare” se soddisfa a una certa forma normale. Il processo, che procede in modo top-downm, può pertanto essere considerato come una progettazione relazionale per analisi

La normalizzazione dei dati può perciò essere considerata come un processo di analisi degli schemi di relazione forniti, basato sulle loro dipendenze funzionali e chiavi primarie, per raggiungere le proprietà desiderate di (1) minimizzazione della ridondanza e (2) minimizzazione delle anomalie. Schemi di relazione  che non soddisfano i test di forma normale engono decomposti in schemi di relazione più piccoli che le superano. La forma normale di una relazione fa riferimento alla più alta condizione di forma normale soddisfatta, e perciò indica il livello al quale è stata normalizzata. Non è sufficiente verificare che ogni schema di relazione sia in 3NF/BCNF, ma si vuole anche garantire proprietà di join senza perdita (garantisce che negli schemi di relazioni dopo una decomposizione non si presenti il problema di generazione di tuple spurie) e proprietà di conservazione delle dipendenze (garantisce il mantenimento dei vincoli di integrità originari, cioè rilevano agg. illeciti).

Una superchiave di R è un insieme di attributi S tali che nessuna coppia di tuple t1 e t2 in un generico stato valido di relazione r di R avrà t1[S] = t2[S]. Una chiave K è una superchiave con la proprietà aggiuntiva che la rimozione di un qualsiasi attributo da K fa sì che K cessi di essere superchiave. Se uno schema di relazione ha più di una chiave, ognuna di esse è detta chiave candidata. Una delle chiavi 
candidate è arbitrariamente nominata chiave primaria, le altre sono dette chiavi secondarie. Un attributo di uno schema di relazione R è detto attributo primo di R se esso è membro di una qualche chiave candidata di R. Un attributo è detto non-primo se non è un attributo primo

- **1NF**: non permette l'uso di attributi multivalore, cioè relazioni dentro relazioni. Si normalizza rimuovendo l'attributo e ponendolo in una relazione separata; espandendo la chiave in modo tale che ci sai una tupla separata sulla stessa relazione; sostituisce gli n valori con n attributi. La prima è la migliore poiché meno ridondante. Presenta il problema delle relazioni nidificate, normalizzabili spostando gli attributi della relazione nidificata in una nuova relazione e propagando la chiave primaria della relazione originaria (decomposizione e propagazione).

- **2NF**: si basa sul concetto di dipendenze funzionale completa. X -> Y è DF completa se la rimozione di un qualsiasi attributo A da X non fa più sussistere la DF, altrimenti è parziale. Uno schema è in 2NF se ogni attributo primo A di R dipende funzionalmente in modo completo dalla chiave primaria di R. Si normalizza decomponendo e preparando una nuova relazione per ogni chiave parziale con i suoi attributi dipendenti. Assicurarsi di mantenere una relazione con la chiave primaria originale e tutti gli attributi funzionalmente dipendenti in modo completo da essa.

- **3NF**: si basa sul concetto di dipendenza funzionale transitiva. X -> Y è DF transitiva se esiste un attributo Z per cui valgono X -> Z e Y -> Z. R è in 3NF se soddisfa 2NF e nessun attributo non-primo di R dipende in modo transitivo dalla chiave primaria. Cioè non deve esserci nessuna dipendenza transitiva di un attributo non-chiave dalla chiave primaria. Si normalizza decomponendo e preparando una relazione che comprenda gli attributi non-chiave che determinano funzionalmente altri attributi non-chiave.

- **BCNF** (Forma Normale di Boyce-Codd): proposta come più semplice di 3NF, è in realtà più restrittiva. Uno schema di relazione R è in BCNF se, ogni volta, che sussiste in R una dipendenza funzionale non-banale X → A, X è una superchiave di R. La sola differenza tra le definizioni di BCNF e di 3NF è che la condizione (b) della 3NF, che consente ad A di essere primo, è assente dalla BCNF. In pratica, la maggior parte degli schemi di relazione in 3NF è anche in BCNF. Solo se in uno schema di relazione R sussiste X → A, con X che non è una superchiave e A attributo primo, R sarà in 3NF ma non in BCNF.

# Algoritmi di Normalizzazione

- Progettazione top-down: schema concenttuale -> modello di dati ad alto livello come EER -> traduzione in insieme di relazioni analizzate sulla base delle loro DF, applicando poi la normalizzazione
- Progettazione bottom-up: tecnica purista, la progettazione parte dalla definizione di DF, poi si applica algoritmo di normalizzazione e ci si assicura che ogni singolo schema raggiunga un livello di qualità associato alla £NF o BCNF.

Gli algoritmi di normalizzazione cominciano da uno 'schema gigante' (detta relazione universale) con tutti gli attributi della base di dati, poi si decompongono ripetutamente basate sulle DF specificate dai progettisti, finché non sono più decomponobili o farlo è indesiderabile. La proprietà desiderabile derivata da questa decomposizione è la lossless-join (si perde informazione) e la conservazione delle dipendenze.

Lo schema di relazione universale R è decomposto in un insieme D di schemi di relazioni R1...Rn più piccoli tali che l'unione è R. D è detto decomposizione di R. Vogliamo il D migliore, cioè che rispetta quelle proprietà desiderabili, e che ogni Ri in D sia in 3NF/BCNF.

Sarebbe utile se ogni X -> Y in F apparisse in uno schema Ri, oppure potesse essere inferibile dalle dipendenze in qualche Ri. Questa è detta 'condizione di conservazione delle dipendenze': si desidera conservare le dipendenze perché ogni dipendenza in F rappresenta un vincolo sulla base di dati. E' sufficiente che l'unione delle dipendenze che sussistono sulle singole relazioni in D siano equivalenti ad F (insieme DF).

Dato F su R, la proiezione di F su Ri è l'insieme di DF X -> Y di F+ tali che gli attributi X U Y siano tutti contenuti in Ri. Perciò la proiezione F su ogni schema Ri di D è proprio F+. D di R conserva le dipendenze rispetto a F se l'unione delle proiezioni di F su ogni Ri è equivalente a F. 

PROPOSIZIONE 1. E' sempre possibile trovare uan decomposizione D che conserva le dipendenze rispetto a F e tale che ogni relazione Ri di D sia in 3NF.
Esiste Algoritmo 1.1 che a partire da F crea un D che conserva le dipendenze e tale che ogni Ri sia 3NF. Non garantisce lossless-join. Algoritmo a Pag. 24.

F è minimale se ogni DF ha come parte destra un solo attributo; non è mai possibile rimuovere una dipendenza da F e avere ancora un insieme di dipendenze equivalente ad F; non è mai possibile sostituire una dipendenza da F e avere ancora un insieme equivalente ad F. Una copertura minimale di F è un insieme minimale di DF Fmin equivalente a F. Esiste un algoritmo per trovare almeno una copertura minimale per ogni insieme F di dipendenze (Pag. 25).

D deve anche soddisfare la losslessjoin (che assicura che non vengano generate tuple spurie quando si applica una join, cioè perdita di informazione). Deve valere per ogni stato valido di relazione, cioè ogni stato che soddisfa le dipendenze in F. La lossless join è sempre definita rispetto ad un insieme specifico F di dipendenze. Formalmente, D dossifa la lossless join rispetto a F se per ogni stato di relazione r di R sussiste che il join naturale di tutte le proiezioni Ri(r) = r. Esiste un algoritmo per verificare se D soddisfa la lossless join rispetto a F (pag. 26).

La domanda successiva è se esiste un algoritmo che decompone un certo R in un D tale che ogni Ri in D sia in BCNF e D sia in lossless join. La risposta è sì, ma prima bisogna indicare due proprietà generali delle decomposizioni con lossless join.
- D = R1, R2 soddisfa lossless join rispetto a F solo se [pag. 28]
- Se D di R gode di lossless join su F se un'altra D1 di Ri gode della losslessjoin rispetto alla proiezione di F su Ri, allora D2 (unione D e D1) gode della lossless join rispetto a R. E' dunque possibile determinare un algoritmo come richiesto (pag. 28).

Se si vuole che una decomposizione goda della proprietà di join senza perdita e conservi le dipendenze, occorre accontentarsi di schemi di relazione in 3NF anziché in BCNF. La decomposizione D di R avrà le seguenti proprietà:
• conserva le dipendenze,
• gode della proprietà di join senza perdita,
• è tale che ogni schema di relazione risultante nella decomposizione sia in 3NF.
Algoritmo a pag. 29. Il passo 3 prevede di individuare una chiave K di R. Per farlo si usa un altro algoritmo a pag. 30.

Tupla dangling: capita se si spinge troppo oltre una decomposizione. Capita se si joina sul null.

# 4NF e Dipendenze Multivalore

Le dipendenze multivalore sono una conseguenza della prima  forma normale (1NF), che impedisce a un attributo in una tupla di conoscere un insieme di valori. Se vi sono 
due o più attributi multivalore indipendenti nello stesso schema di relazione, si ha il problema di dover ripetere ogni valore di uno degli attributi per ciascun valore dell’altro attributo per mantenere consistente lo stato della relazione e per conservare l’indipendenza tra gli attributi coinvolti. Questo vincolo viene espresso mediante una dipendenza multivalore. 

Una dipendenza multivalore X ↠ Y specificata sullo schema di relazione R, dove X e Y sono sottoinsiemi di R, specifica il seguente vincolo su qualsiasi stato di relazione r di R; se in r esistono due tuple t1 e t2 tali che t1[X] = t2[Y], allora in r devono esistere anche due tuple, t3 e t4 con le seguenti proprietà, dove viene usato Z per indicare (R – (X ∪ Y)):
- t3[X] = t4[X] = t1[X] = t2[X]
- t3[X] = t1[X] = t4[X] = t2[X]
- t3[X] = t2[X] = t4[X] = t1[X]

Ogni volta che sussiste X ↠ Y, diciamo che X multidetermina Y. A causa della simmetria nella definizione, quando X ↠ Y sussiste in R , lo stesso fa X ↠ Z; quindi X ↠ Y implica X ↠ Z e perciò talvolta viene scritto come X ↠ Y|Z. La definizione formale specifica che, dato un particolare valore di X, l’insieme di valori di Y determinato da questo valore di X è determinato completamente solo da X e non dipende dai valori dei restanti attributi in Z di R. Ogni volta che esistono due tuple che hanno valori distinti di Y ma lo stesso valore di X, questi valori di  Y devono essere ripetuti in tuple separate con ogni valore distinto di Z che si presenta con quello stesso valore di X. Questo corrisponde informalmente al fatto che Y è un attributo multivalore delle entità rappresentate dalle tuple in R.

Definizione: Uno schema di relazione R è in **4NF** rispetto a un insieme di dipendenze F (che include le dipendenze funzionali e multivalore) se, per ogni dipendenza multivalore non banale X ↠ Y in F+, X è una superchiave di R.

Gli schemi di relazione R1 e R2 costituiscono una decomposizione non-additiva di R rispetto a un insieme F di dipendenze funzionali e multivalore se e solo se: R1 intersecato R2 multidetermina R1 - R2.
Esiste un algoritmo che crea una decomposizione non-additiva che produce schemi di relazione che sono in 4NF anziché in BCNF. Pagina 36.